use data_model::StateChange;
use leptos::{error::Result, *};
use reqwasm;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
struct Device {
    name: String, // "name" is the name given to the key field in the JSON generated by KV::LIST
}

// Get a List of devices - returns a vector of DeviceId as String
async fn api_device_list() -> Result<Vec<String>> {
    let res = reqwasm::http::Request::get("/api/device/list")
        .send()
        .await?
        .json::<Vec<Device>>()
        .await?
        .into_iter()
        .map(|device| device.name)
        .collect::<Vec<String>>();
    Ok(res)
}

// Get the state (last StateChange event) for a Device
async fn api_device_status_get(key: &str) -> Result<StateChange> {
    let res = reqwasm::http::Request::get(&format!("/api/device/status/{key}"))
        .send()
        .await?
        .json::<StateChange>()
        .await?;
    Ok(res)
}

// Get the list of states of devices - as a vector of the last StateChange event for each device
async fn api_device_statechanges_list() -> Result<Vec<StateChange>> {
    let device_ids = api_device_list().await?;

    let mut statuses = vec![];

    for device_id in device_ids {
        statuses.push(api_device_status_get(&device_id.to_string()).await?);
    }

    Ok(statuses)
}

// Show a page of devices, organized into groups according to their state
#[component]
#[allow(non_snake_case)]
pub fn DeviceStatusList() -> impl IntoView {
    let device_state_changes =
        create_local_resource(move || (), |_| api_device_statechanges_list());

    view! {
        <h1>"Device Status"</h1> {
            move || match device_state_changes.get() {
                None => view!{ <p>"Searching for devices..."</p> }.into_view(),
                Some(Ok(devices_states)) => {
                    if devices_states.is_empty() {
                        view!{ <p>No devices found</p> }.into_view()
                    } else {
                        // TODO move all this into the api method
                        let mut state_change_map = HashMap::<String, Vec<StateChange>>::new();
                        for state_change in devices_states {
                            state_change_map.entry(state_change.state.to_string())
                                .or_insert_with(Vec::new)
                                .push(state_change);
                        }
                        // For each state get the vector of StateChanges for the devices in that state
                        ["Reporting", "Offline", "Stopped"].map(|state| {
                            match state_change_map.get(state) {
                                Some(state_change_vec) => {
                                    view!{
                                        <ul>{state}
                                        {
                                            state_change_vec.into_iter()
                                                .map(|state_change| view! {<li>{state_change.id.to_string()}</li>})
                                                .collect_view()
                                        }
                                        </ul>
                                    }.into_view()
                                },
                                None => {
                                    view!{ <ul>{state}</ul>}.into_view()
                                }
                            }
                        }).collect_view()
                    }
                },
                Some(Err(_)) => view! {<p>"Error finding devices"</p>}.into_view(),
            }
        }
        <button on:click=move |_| { device_state_changes.refetch() }>
            "Refresh"
        </button>
    }
}
