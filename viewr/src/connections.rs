use data_model::{DeviceDetails, StateChange};
use leptos::{error::Result, *};
use reqwasm;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
struct ConnectionDevice {
    name: String, // "name" is the name given to the key field in the JSON generated by KV::LIST
}

async fn api_connection_device_statechange_get(key: &str) -> Result<StateChange> {
    let res = reqwasm::http::Request::get(&format!("/api/connection/{key}"))
        .send()
        .await?
        .json::<StateChange>()
        .await?;
    Ok(res)
}

// Get the DeviceDetails struct for a device from the KV store, where 'key' is the device_id
async fn api_device_details_get(key: &str) -> Result<DeviceDetails> {
    Ok(
        reqwasm::http::Request::get(&format!("/api/device/details/{key}"))
            .send()
            .await?
            .json::<DeviceDetails>()
            .await?,
    )
}

// Get the list of all keys of entries in the ConnectionDeviceStatus KV Namespace
async fn api_connection_device_list() -> Result<Vec<String>> {
    let res = reqwasm::http::Request::get("/api/connection/list")
        .send()
        .await?
        .json::<Vec<ConnectionDevice>>()
        .await?
        .into_iter()
        .map(|connection_device| connection_device.name)
        .collect::<Vec<String>>();
    Ok(res)
}

async fn api_connection_device_state_list(
) -> Result<HashMap<String, Vec<(String, StateChange, String)>>> {
    let connection_device_ids = api_connection_device_list().await?;

    let mut statuses = HashMap::<String, Vec<(String, StateChange, String)>>::new();

    for connection_device_id in connection_device_ids {
        if let Some((connection, device_id)) = connection_device_id.split_once("::") {
            statuses
                .entry(connection.to_string())
                .or_insert_with(Vec::new)
                .push((
                    device_id.to_string(),
                    api_connection_device_statechange_get(&connection_device_id.to_string())
                        .await?,
                    api_device_details_get(&device_id.to_string())
                        .await
                        .map_or("DEV".to_string(), |d| {
                            d.friendly_name.clone().unwrap_or("DEV".to_string())
                        }),
                ));
        }
    }

    Ok(statuses)
}

#[component]
#[allow(non_snake_case)]
pub fn ConnectionDeviceStatusList() -> impl IntoView {
    let connection_device_statuses =
        create_local_resource(move || (), |_| api_connection_device_state_list());

    view! {
        <h1>"Connection::Device States"</h1>
        {
            move || match connection_device_statuses.get() {
                None => view!{ <p>"Searching for devices..."</p> }.into_view(),
                Some(Ok(connection_device_states)) => {
                    if connection_device_states.is_empty() {
                        view!{ <p>No connections found</p> }.into_view()
                    } else {
                        view!{
                            <ul> {
                                connection_device_states.iter().map(|(connection, device_status_list)| {
                                    view! {
                                        <li>
                                            {connection}
                                            {
                                                device_status_list.iter().map(|(device_id, state_change, name)| {
                                                    let status_style = format!("tooltip device-status {}", state_change.state);
                                                    view!{
                                                        <div class=status_style>{name}
                                                            <span class="tooltiptext">{device_id}</span>
                                                        </div>}
                                                }).collect_view()
                                            }
                                        </li>
                                    }
                                }).collect_view()
                            } </ul>
                        }.into_view()
                    }
                },
                Some(Err(_)) => view! {<p>"Error finding connections"</p>}.into_view(),
            }
        }
        <button on:click=move |_| { connection_device_statuses.refetch() }>
            "Refresh"
        </button>
    }
}
